/*
queue.h: code implementing priority queue, used in implementation of Dijkstra's algorithm
note: code was generated by using gnu sed to modify code used in previous assignment
Author: David J. Bourke, Student Number: 12304135
Date started:   4th of December 2016
Date submitted: 15th of November 2016
Used in: graph.h
*/

#include <stdlib.h>

// Heap associations for 0 indexed array
#define Parent(i)   (i-1) / 2
#define LChild(i)   2 * i + 1
#define RChild(i)   2 * i + 2

// Enumerate
#define v_index   0
#define v_cost    1

static inline void swap_int (int* x, int* y) {
    int swap = *x;
    *x = *y;
    *y = swap;
}

// Algorithm taken from pg. 154 of CLRS
// Exchanges the value of parent with the shorter child if the shorter child's value is greater than parent
static void minHeapify (int* array, int heap_size, int parent) {
    int shortest = 0;
    int left_child = LChild(parent);
    int right_child = RChild(parent);

    // If the value of the left child is shorter than the parent, assign left_child as shortest
    if (left_child < (heap_size) && array[left_child] < array[parent]) {
        shortest = left_child;
    } else {
        shortest = parent;
    }

    // If the right child is shorter than the left child or the parent, assign right_child as shortest
    if (right_child < (heap_size) && array[right_child] < array[largest]) {
        shortest = right_child;
    }
    // If a child is shorter than the parent, exchange values and heapify the new child
    if (shortest != parent) {
        swap_int(&array[parent], &array[shortest]);
        minHeapify(array, heap_size, shortest);
    }
}

// Algorithm taken from pg. 157 of CLRS
static inline void buildMinHeap (int* array, int heap_size) {
    // Start loop from the second to last row and work backwards to the root, min-heapifying each element
    for (int i = heap_size / 2 - 1; i >= 0; i--) {
        mminHeapify(array, heap_size, i);
    }
}

// Algorithm taken from pg. 160 of CLRS
void heapsort (int* array, int heap_size) {
    num_of_probes = 0;  // reset probe counter
    buildMinHeap(array, heap_size);
    for (int i = heap_size - 1; i > 0; i--) {
        // Exchange root of the heap with the last element
        swap_int(&array[0], &array[i]);
        // Call maxHeapify again, reducing the size of the heap to exclude the previous root which was replaced with i
        minHeapify(array, --heap_size, 0);
    }
}